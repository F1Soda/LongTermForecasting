import simfin as sf
from simfin.names import (TOTAL_RETURN, CLOSE, VOLUME, TICKER,
                          PSALES, DATE)
from simfin.utils import BDAYS_PER_YEAR

from itertools import chain, combinations
import seaborn as sns


# String constants used as names in these plots.
WINDOW_LENGTH = 'Window Length'
MEAN_RETURN = 'Mean Daily Return'
STD_RETURN = 'Std.Dev. Daily Return'
CORR = 'Correlation'
TICKER2 = 'Ticker2'
TICKER_PAIR = 'Ticker Pair'



def plot_rolling_stats(df, stat_name, tickers, windows,
                       col_ticker=TICKER, y_dashed_line=None):
    """
    Plot rolling statistics for multiple stock-tickers or
    ticker-pairs. Each ticker or ticker-pair has its separate
    sub-plot on an individual row.
    
    :param df:
        Pandas DataFrame with data to be plotted.
        Generated by the function `calc_rolling_stats`.
        
    :param stat_name:
        String with name for the statistic.
        
    :param tickers:
        List of strings for stock-tickers.
    
    :param windows:
        List of integers with window-lengths.
        
    :param col_ticker:
        String with name of column in `df` used to plot
        different rows. E.g. TICKER or TICKER_PAIR.
        
    :param y_dashed_line:
        If not `None` then plot a horizontal black dashed
        line at this value.
        
    :return:
        Matplotlib Axis object.
    """
    # Plot the rolling statistics in sub-plots for each ticker.
    facet_kws = {'sharey': False, 'sharex': True}
    g = sns.relplot(x=DATE, y=stat_name, hue=WINDOW_LENGTH,
                    row=col_ticker, data=df, kind='line',
                    facet_kws=facet_kws, height=4, aspect=10/4)

    # Add a horizontal black dashed line?
    if y_dashed_line is not None:
        for ax in g.axes:
            # Plot dashed black line to indicate regions of loss vs. gain.
            ax[0].axhline(y=y_dashed_line, color='black', linestyle='dashed')

    # Adjust padding.
    g.tight_layout()

    return g


def draw_return_statatistics_plots(df_mean, df_std, df_corr, tickers, windows):
    # Convert mean to DataFrame that can be plotted by Seaborn.
    id_vars = [DATE, TICKER]
    df_mean = df_mean.reset_index().melt(id_vars=id_vars,
                                         var_name=WINDOW_LENGTH,
                                         value_name=MEAN_RETURN)

    # Convert std.dev. to DataFrame that can be plotted by Seaborn.
    df_std = df_std.reset_index().melt(id_vars=id_vars,
                                       var_name=WINDOW_LENGTH,
                                       value_name=STD_RETURN)

    # Combine two index columns with tickers into a single ticker-pair.
    df_corr = df_corr.reset_index()
    df_corr[TICKER_PAIR] = list(zip(df_corr[TICKER], df_corr[TICKER2]))
    df_corr = df_corr.drop(columns=[TICKER, TICKER2])
    
    ticker_pairs = list(combinations(tickers, r=2))

    # Only use rows that have relevant ticker-pairs.
    mask = df_corr[TICKER_PAIR].isin(ticker_pairs)
    df_corr = df_corr.loc[mask]

    # Convert corr. to DataFrame that can be plotted by Seaborn.
    df_corr = df_corr.melt(id_vars=[DATE, TICKER_PAIR],
                           var_name=WINDOW_LENGTH, value_name=CORR)
    
        # Plot the rolling means.
    plot_rolling_stats(df=df_mean, stat_name=MEAN_RETURN,
                       col_ticker=TICKER, tickers=tickers,
                       windows=windows, y_dashed_line=1.0)

    # Plot the rolling std.dev.
    plot_rolling_stats(df=df_std, stat_name=STD_RETURN,
                       col_ticker=TICKER, tickers=tickers,
                       windows=windows, y_dashed_line=0.0)

    # Plot the rolling correlations.
    plot_rolling_stats(df=df_corr, stat_name=CORR,
                       col_ticker=TICKER_PAIR, tickers=tickers,
                       windows=windows, y_dashed_line=0.0)   